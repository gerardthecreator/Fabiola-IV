<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Módulo Interactivo: Cinemática del Velero</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Oswald:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- MathJax para renderizar LaTeX (Configuración Segura y Probada) -->
    <script>
        MathJax = {
            tex: { 
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                // Macros con nombres seguros que no causan recursividad
                macros: {
                    V: ['\\vec{#1}', 1],
                    ihat: '\\hat{i}',
                    jhat: '\\hat{j}'
                }
            },
            svg: { fontCache: 'global' },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    document.dispatchEvent(new Event('MathJaxReady'));
                }
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <style>
        :root { --bg-color: #e0e0e0; --primary-font-color: #3c3c3c; --accent-color: #c0392b; --accent-color-dark: #a93226; --vector-color-r1: #2980b9; --vector-color-r2: #27ae60; --vector-color-delta: #f39c12; --card-padding: 1.5rem; --card-border-radius: 1.25rem; --font-title: 'Anton', sans-serif; --font-body: 'Oswald', sans-serif; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: var(--font-body); background-color: var(--bg-color); color: var(--primary-font-color); line-height: 1.7; padding: 1.25rem; display: flex; justify-content: center; }
        main { max-width: 800px; width: 100%; }
        h1, h2, h3 { font-family: var(--font-title); letter-spacing: 1px; color: #333; text-align: center; margin-bottom: 1.25rem; }
        h1 { font-size: 2.5rem; text-transform: uppercase; }
        h2 { font-size: 1.8rem; display: flex; align-items: center; justify-content: center; gap: 0.6rem; }
        h3 { font-size: 1.5rem; text-align: left; color: var(--accent-color); margin-top: 2rem; }
        p, li { font-size: 1.1rem; font-weight: 300; margin-bottom: 1rem; }
        strong { font-weight: 500; }
        .card { background: var(--bg-color); padding: var(--card-padding); border-radius: var(--card-border-radius); margin-bottom: 2rem; box-shadow: 9px 9px 16px #bebebe, -9px -9px 16px #ffffff; }
        #visualizacion-container { position: relative; display: flex; flex-direction: column; align-items: center; gap: 1.25rem; }
        #vector-canvas { background: var(--bg-color); border-radius: var(--card-border-radius); box-shadow: inset 7px 7px 14px #bebebe, inset -7px -7px 14px #ffffff; width: 100%; max-width: 500px; height: auto; aspect-ratio: 1/1; cursor: grab; }
        #vector-canvas:active { cursor: grabbing; }
        .zoom-controls { position: absolute; top: 1.25rem; right: 1.25rem; display: flex; flex-direction: column; gap: 0.5rem; }
        .zoom-btn { width: 35px; height: 35px; font-size: 1.5rem; font-weight: bold; border: none; border-radius: 50%; background: var(--bg-color); box-shadow: 3px 3px 6px #bebebe, -3px -3px 6px #ffffff; cursor: pointer; transition: all 0.2s ease; }
        .zoom-btn:hover { color: var(--accent-color); }
        .zoom-btn:active, .zoom-btn:focus { box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff; outline: 2px solid var(--accent-color); outline-offset: 2px; }
        .controls { display: flex; gap: 0.8rem; flex-wrap: wrap; justify-content: center; }
        .control-btn { font-family: var(--font-body); font-size: 0.9rem; font-weight: 400; padding: 0.6rem 1rem; border: none; border-radius: 0.6rem; cursor: pointer; background: var(--bg-color); box-shadow: 5px 5px 10px #bebebe, -5px -5px 10px #ffffff; transition: all 0.2s ease-in-out; color: var(--primary-font-color); }
        .control-btn:hover { color: var(--accent-color); }
        .control-btn:active, .control-btn:focus { box-shadow: inset 3px 3px 7px #bebebe, inset -3px -3px 7px #ffffff; color: var(--accent-color-dark); outline: 2px solid var(--accent-color); outline-offset: 2px; }
        .control-btn:disabled { color: #999; cursor: not-allowed; box-shadow: inset 3px 3px 7px #bebebe, inset -3px -3px 7px #ffffff; }
        .formula-box { background: var(--bg-color); padding: 1.25rem; margin-top: 1rem; border-radius: 1rem; box-shadow: inset 5px 5px 10px #bebebe, inset -5px -5px 10px #ffffff; overflow-x: auto; text-align: center; }
        #respuestas-container .respuesta-item { font-size: 1.2rem; font-weight: 400; background: #f9ebea; color: var(--accent-color-dark); padding: 1rem; border-radius: 0.6rem; border-left: 5px solid var(--accent-color); margin-bottom: 0.6rem; }
        @media (max-width: 640px) { body { padding: 0.8rem; } h1 { font-size: 2rem; } h2 { font-size: 1.5rem; } .card { padding: 1.25rem; } .controls { flex-direction: column; width: 100%; } .control-btn { width: 100%; } .zoom-controls { top: 1rem; right: 1rem; } .zoom-btn { width: 30px; height: 30px; font-size: 1.2rem; } }
    </style>
</head>
<body>

    <main>
        <h1 id="main-title"></h1>
        <section id="enunciado-container" class="card"></section>

        <section id="visualizacion-container" class="card">
            <h2>Visualización del Desplazamiento</h2>
            <canvas id="vector-canvas" width="500" height="500"></canvas>
            <div class="zoom-controls">
                <button id="btn-zoom-in" class="zoom-btn" aria-label="Acercar visualización">+</button>
                <button id="btn-zoom-out" class="zoom-btn" aria-label="Alejar visualización">-</button>
            </div>
            <div class="controls">
                <button id="btn-step1" class="control-btn">1. Dibujar Posición Inicial ($\V{r}_1$)</button>
                <button id="btn-step2" class="control-btn" disabled>2. Dibujar Posición Final ($\V{r}_2$)</button>
                <button id="btn-step3" class="control-btn" disabled>3. Mostrar Desplazamiento ($\Delta\V{r}$)</button>
                <button id="btn-reset" class="control-btn">Reiniciar</button>
            </div>
        </section>

        <section id="solucion-container" class="card"></section>
        <section id="respuestas-container" class="card" aria-live="polite"></section>
    </main>

    <!-- TEMPLATES PARA CONTENIDO DINÁMICO -->
    <template id="template-enunciado"><h2 class="enunciado-titulo"></h2><div class="enunciado-parrafos"></div><ul class="enunciado-preguntas"></ul></template>
    <template id="template-solucion"><div class="step-card"><h3 class="solucion-step-titulo"></h3><p class="solucion-step-explicacion"></p><div class="formula-box solucion-step-formula"></div></div></template>
    <template id="template-respuesta"><p class="respuesta-item"></p></template>

    <script>
    const ejercicioVelero = {
        titulo: "Ejercicio: Cinemática del Velero",
        enunciado: {
            titulo: "Enunciado",
            parrafos: [
                "Un barco de vela tiene las coordenadas $(x_1, y_1) = (130\\ \\text{m}, 205\\ \\text{m})$ en el instante $t_1 = 60.0\\ \\text{s}$.",
                "Dos minutos más tarde, en el instante $t_2$, sus coordenadas son $(x_2, y_2) = (110\\ \\text{m}, 218\\ \\text{m})$.",
                "Para $t \\ge 20\\ \\text{s}$, la posición del barco en función del tiempo está dada por: $x(t) = b_1 + b_2 t$ y $y(t) = c_1 + c_2/t$, donde $b_1 = 100\\ \\text{m}$, $b_2 = 0.500\\ \\text{m/s}$, $c_1 = 200\\ \\text{m}$ y $c_2 = 360\\ \\text{m} \\cdot \\text{s}$."
            ],
            preguntas: [
                "<strong>(a)</strong> Determinar la <strong>velocidad media</strong> en este intervalo de dos minutos. Expresar $\\V{v}_m$ en función de sus componentes rectangulares.",
                "<strong>(b)</strong> Determinar el <strong>módulo y la dirección</strong> de esta velocidad media.",
                "<strong>(c)</strong> Calcular la <strong>velocidad instantánea</strong> en función del tiempo para $t \\ge 20\\ \\text{s}$."
            ]
        },
        solucion: {
            titulo: "Solución Detallada",
            pasos: [
                {
                    titulo: "Paso 1: Calcular el Intervalo de Tiempo ($\Delta t$)",
                    explicacion: "El intervalo de tiempo es de 'dos minutos'. Convertimos esto a segundos para ser consistentes con las unidades de $t_1$.",
                    formula: `$\\Delta t = 2\\ \\text{min} \\times \\frac{60\\ \\text{s}}{1\\ \\text{min}} = 120\\ \\text{s}$`
                },
                {
                    titulo: "Paso 2: Calcular el Vector de Desplazamiento ($\Delta\\V{r}$)",
                    explicacion: "El desplazamiento es la diferencia entre el vector de posición final y el inicial. Calculamos las componentes por separado.",
                    formula: `$\\Delta\\V{r} = \\V{r}_2 - \\V{r}_1 = (x_2 - x_1)\\ihat + (y_2 - y_1)\\jhat$ <br>
                              $\\Delta x = 110\\ \\text{m} - 130\\ \\text{m} = -20\\ \\text{m}$ <br>
                              $\\Delta y = 218\\ \\text{m} - 205\\ \\text{m} = 13\\ \\text{m}$ <br>
                              $\\Delta\\V{r} = (-20\\ihat + 13\\jhat)\\ \\text{m}$`
                },
                {
                    titulo: "(a) Calcular la Velocidad Media ($\V{v}_m$)",
                    explicacion: "La velocidad media es el desplazamiento dividido por el intervalo de tiempo. Aplicamos las reglas de cifras significativas en la división (el resultado tiene tantas cifras como el dato con menos cifras).",
                    formula: `$\\V{v}_m = \\frac{\\Delta\\V{r}}{\\Delta t} = \\frac{-20\\ihat + 13\\jhat}{120\\ \\text{s}}$ <br>
                              $v_{mx} = \\frac{-20\\ \\text{m}}{120\\ \\text{s}} \\approx -0.1666... \\rightarrow \\boldsymbol{-0.17\\ \\text{m/s}}$ (2 cifras sig. por -20 m) <br>
                              $v_{my} = \\frac{13\\ \\text{m}}{120\\ \\text{s}} \\approx 0.10833... \\rightarrow \\boldsymbol{0.11\\ \\text{m/s}}$ (2 cifras sig. por 13 m) <br>
                              $\\V{v}_m = (-0.17\\ihat + 0.11\\jhat)\\ \\text{m/s}$`
                },
                {
                    titulo: "(b) Calcular el Módulo de la Velocidad Media",
                    explicacion: "Usamos el teorema de Pitágoras con las componentes de la velocidad media. Para mayor precisión, usamos los valores sin redondear en el cálculo intermedio y redondeamos el resultado final a 2 cifras significativas.",
                    formula: `$|\\V{v}_m| = \\sqrt{v_{mx}^2 + v_{my}^2} = \\sqrt{(-0.1666...)^2 + (0.10833...)^2}$ <br>
                              $|\\V{v}_m| = \\sqrt{0.02777... + 0.01173...} = \\sqrt{0.03951...} \\approx 0.1987... \\rightarrow \\boldsymbol{0.20\\ \\text{m/s}}$`
                },
                {
                    titulo: "(b) Calcular la Dirección de la Velocidad Media",
                    explicacion: "La dirección se calcula con la arcotangente. Como $v_{mx}$ es negativa y $v_{my}$ es positiva, el vector está en el segundo cuadrante. El ángulo se puede expresar respecto al eje +x o de forma descriptiva.",
                    formula: `$\\theta = \\arctan\\left(\\frac{v_{my}}{v_{mx}}\\right) = \\arctan\\left(\\frac{0.11}{-0.17}\\right) \\approx -33^\\circ$ <br>
                              Ajuste al 2º cuadrante: $\\theta = 180^\\circ - 33^\\circ = \\boldsymbol{147^\\circ}$ respecto al eje +x. <br>
                              O, más descriptivo, el ángulo $\\alpha$ al Oeste del Norte: <br>
                              $\\alpha = \\arctan\\left(\\frac{|v_{mx}|}{|v_{my}|}\\right) = \\arctan\\left(\\frac{0.17}{0.11}\\right) \\approx \\boldsymbol{57^\\circ}$`
                },
                {
                    titulo: "(c) Calcular la Velocidad Instantánea ($\V{v}(t)$)",
                    explicacion: "La velocidad instantánea es la derivada del vector de posición con respecto al tiempo. Derivamos cada componente por separado.",
                    formula: `$\\V{v}(t) = \\frac{d\\V{r}(t)}{dt} = \\frac{dx(t)}{dt}\\ihat + \\frac{dy(t)}{dt}\\jhat$`
                },
                {
                    titulo: "Derivada de las Componentes",
                    explicacion: "Calculamos la derivada de $x(t)$ y $y(t)$ usando las reglas de derivación.",
                    formula: `$v_x(t) = \\frac{d}{dt}(b_1 + b_2 t) = b_2 = \\boldsymbol{0.500\\ \\text{m/s}}$ <br>
                              $y(t) = c_1 + c_2 t^{-1}$ <br>
                              $v_y(t) = \\frac{d}{dt}(c_1 + c_2 t^{-1}) = -1 \\cdot c_2 t^{-2} = -\\frac{c_2}{t^2} = \\boldsymbol{-\\frac{360}{t^2}\\,\\frac{\\text{m}}{\\text{s}}}$ <br>
                              El vector final es: $\\V{v}(t) = \\left(0.500\\ihat - \\frac{360}{t^2}\\jhat\\right)\\,\\frac{\\text{m}}{\\text{s}}$`
                }
            ]
        },
        respuestas: {
            titulo: "Respuestas Finales",
            items: [
                "<strong>(a) Velocidad Media:</strong> $\\tiny\\V{v}_m = (-0.17\\ihat + 0.11\\jhat)\\ \\text{m/s}$",
                "<strong>(b) Módulo y Dirección:</strong> El módulo es <strong>0.20 m/s</strong>. La dirección es <strong>147°</strong> respecto al eje +x, o <strong>57° al Oeste del Norte</strong>.",
                "<strong>(c) Velocidad Instantánea:</strong> $\\tiny\\V{v}(t) = \\left(0.500\\ihat - \\frac{360}{t^2}\\jhat\\right)\\,\\frac{\\text{m}}{\\text{s}}$ para $t \\ge 20\\ \\text{s}$."
            ]
        }
    };

    document.addEventListener('DOMContentLoaded', () => {
        
        const elementosParaRenderizar = [];

        function poblarContenido() {
            const data = ejercicioVelero;
            document.getElementById('main-title').innerHTML = data.titulo;

            const enunciadoContainer = document.getElementById('enunciado-container');
            const enunciadoTemplate = document.getElementById('template-enunciado');
            const enunciadoClone = enunciadoTemplate.content.cloneNode(true);
            enunciadoClone.querySelector('.enunciado-titulo').innerHTML = data.enunciado.titulo;
            const parrafosDiv = enunciadoClone.querySelector('.enunciado-parrafos');
            data.enunciado.parrafos.forEach(p => { const pElem = document.createElement('p'); pElem.innerHTML = p; parrafosDiv.appendChild(pElem); });
            const preguntasUl = enunciadoClone.querySelector('.enunciado-preguntas');
            data.enunciado.preguntas.forEach(q => { const liElem = document.createElement('li'); liElem.innerHTML = q; preguntasUl.appendChild(liElem); });
            enunciadoContainer.appendChild(enunciadoClone);
            elementosParaRenderizar.push(enunciadoContainer);

            const solucionContainer = document.getElementById('solucion-container');
            const solucionTemplate = document.getElementById('template-solucion');
            const solucionHeader = document.createElement('h2');
            solucionHeader.textContent = data.solucion.titulo;
            solucionContainer.appendChild(solucionHeader);
            data.solucion.pasos.forEach(step => {
                const stepClone = solucionTemplate.content.cloneNode(true);
                stepClone.querySelector('.solucion-step-titulo').innerHTML = step.titulo;
                stepClone.querySelector('.solucion-step-explicacion').innerHTML = step.explicacion;
                if (step.formula) { stepClone.querySelector('.solucion-step-formula').innerHTML = step.formula; } else { stepClone.querySelector('.formula-box').remove(); }
                solucionContainer.appendChild(stepClone);
            });
            elementosParaRenderizar.push(solucionContainer);

            const respuestasContainer = document.getElementById('respuestas-container');
            const respuestaTemplate = document.getElementById('template-respuesta');
            const respuestasHeader = document.createElement('h2');
            respuestasHeader.textContent = data.respuestas.titulo;
            respuestasContainer.appendChild(respuestasHeader);
            data.respuestas.items.forEach(item => { const itemClone = respuestaTemplate.content.cloneNode(true); itemClone.querySelector('.respuesta-item').innerHTML = item; respuestasContainer.appendChild(itemClone); });
            elementosParaRenderizar.push(respuestasContainer);
        }

        function renderizarFormulas() {
            if (typeof MathJax !== 'undefined' && MathJax.startup.isReady) {
                MathJax.typesetPromise(elementosParaRenderizar).catch((err) => console.error("Error al renderizar MathJax:", err));
            }
        }

        poblarContenido();
        document.addEventListener('MathJaxReady', renderizarFormulas);
        if (typeof MathJax !== 'undefined' && MathJax.startup.isReady) {
            renderizarFormulas();
        }

        // --- Lógica del Canvas (Adaptada al nuevo ejercicio) ---
        const canvas = document.getElementById('vector-canvas');
        const ctx = canvas.getContext('2d');
        const btns = { step1: document.getElementById('btn-step1'), step2: document.getElementById('btn-step2'), step3: document.getElementById('btn-step3'), reset: document.getElementById('btn-reset'), zoomIn: document.getElementById('btn-zoom-in'), zoomOut: document.getElementById('btn-zoom-out') };
        
        const R1 = { x: 130, y: 205 };
        const R2 = { x: 110, y: 218 };
        const DELTA_R = { x: -20, y: 13 };
        
        const ESCALA_BASE = 1.5; 
        let scale = 1.0;
        const ORIGEN = { x: 50, y: canvas.height - 50 };
        let drawnVectors = [];

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            dibujarEjes();
            drawnVectors.forEach(v => drawStaticVector(v.vector, v.color, v.etiqueta, v.startPoint));
        }

        function dibujarEjes() {
            ctx.save();
            ctx.translate(ORIGEN.x, ORIGEN.y);
            ctx.scale(1, -1); 
            const currentScale = ESCALA_BASE * scale;
            const width = canvas.width;
            const height = canvas.height;
            ctx.beginPath();
            ctx.moveTo(-width, 0); ctx.lineTo(width, 0);
            ctx.moveTo(0, -height); ctx.lineTo(0, height);
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1 / scale;
            ctx.setLineDash([5 / scale, 5 / scale]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.scale(1, -1);
            ctx.font = `${14 / scale}px Oswald`;
            ctx.fillStyle = '#555';
            ctx.textAlign = 'left';
            ctx.fillText('Eje X (m)', 10/scale, -10/scale);
            ctx.fillText('Eje Y (m)', 10/scale, -(canvas.height - 70));
            ctx.restore();
        }

        function drawStaticVector(vector, color, etiqueta, startPoint) {
            const currentScale = ESCALA_BASE * scale;
            ctx.save();
            ctx.translate(ORIGEN.x, ORIGEN.y);
            ctx.scale(1, -1);
            const startX = startPoint.x * currentScale;
            const startY = startPoint.y * currentScale;
            const endX = (startPoint.x + vector.x) * currentScale;
            const endY = (startPoint.y + vector.y) * currentScale;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3 / scale;
            ctx.stroke();
            ctx.save();
            ctx.translate(endX, endY);
            ctx.rotate(-Math.atan2(vector.y, vector.x));
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(-10/scale, 5/scale); ctx.lineTo(-10/scale, -5/scale); ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.scale(1, -1);
            const labelX = startX + (vector.x * currentScale) / 2;
            const labelY = -(startY + (vector.y * currentScale) / 2);
            ctx.font = `bold ${16/scale}px Oswald`;
            ctx.fillStyle = color;
            ctx.fillText(etiqueta, labelX + 10/scale, labelY - 10/scale);
            ctx.restore();
        }

        function animarVector(vector, color, etiqueta, startPoint = {x: 0, y: 0}) {
            drawnVectors.push({vector, color, etiqueta, startPoint});
            const duracion = 1000;
            let inicio = null;
            function paso(timestamp) {
                if (!inicio) inicio = timestamp;
                const progreso = Math.min((timestamp - inicio) / duracion, 1);
                redrawCanvas();
                const currentScale = ESCALA_BASE * scale;
                ctx.save();
                ctx.translate(ORIGEN.x, ORIGEN.y);
                ctx.scale(1, -1);
                const startX = startPoint.x * currentScale;
                const startY = startPoint.y * currentScale;
                const currentX = (startPoint.x + vector.x * progreso) * currentScale;
                const currentY = (startPoint.y + vector.y * progreso) * currentScale;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3 / scale;
                ctx.stroke();
                ctx.restore();
                if (progreso === 1) { redrawCanvas(); } else { requestAnimationFrame(paso); }
            }
            requestAnimationFrame(paso);
        }
        
        function resetCanvas() {
            scale = 1.0;
            drawnVectors = [];
            redrawCanvas();
            btns.step1.disabled = false;
            btns.step2.disabled = true;
            btns.step3.disabled = true;
        }

        btns.step1.addEventListener('click', () => { animarVector(R1, 'var(--vector-color-r1)', 'r₁'); btns.step1.disabled = true; btns.step2.disabled = false; });
        btns.step2.addEventListener('click', () => { animarVector(R2, 'var(--vector-color-r2)', 'r₂'); btns.step2.disabled = true; btns.step3.disabled = false; });
        btns.step3.addEventListener('click', () => { animarVector(DELTA_R, 'var(--vector-color-delta)', 'Δr', R1); btns.step3.disabled = true; });
        btns.reset.addEventListener('click', resetCanvas);
        btns.zoomIn.addEventListener('click', () => { scale *= 1.25; redrawCanvas(); });
        btns.zoomOut.addEventListener('click', () => { scale /= 1.25; redrawCanvas(); });

        resetCanvas();
    });
    </script>

</body>
</html>